# 多线程
主要内容  
* 线程简介  
* 线程实现，重点  
* 线程状态  
* 线程同步，重点  
* 线程通信问题  
* 高级主题，应用  

# 一、进程与线程
* 多任务：看起来是多个任务都在做，本质上大脑在同一时间依旧只做了一件事情  
* 多线程：类似于多个车道，普通方法调用只有主线程一条执行路径，而多线程是多条执行路径，主线程和子线程并行交替执行。  
* 进程Process：在操作系统中运行的程序就是进程，一个进程可以有多个线程，一个进程至少有一个线程（main线程），进程是执行程序的一次执行过程，是一个动态的概念，
是系统资源分配的单位。  
* 线程Thread：线程是CPU调度和执行的单位。注意：很多多线程是模拟出来的，真正的多线程是指有多个CPU，即多核，如服务器。
如果模拟出来的多线程，即在一个CPU的情况下，在同一个时间点，CPU只能执行一个代码，因为切换得很快，所以就有同时执行的错觉。
## 1.1 核心概念整理
* 线程就是独立的执行路径；  
* 在程序运行时，及时没有自己创建线程，后台也会有多个线程，如mian线程、gc线程（垃圾回收线程）；  
* main()称之为主线程，为系统的入口，用于执行整个程序；  
* 在一个进程中，如果开辟了多个线程，线程的运行由调度器安排调度，调度器是与操作系统紧密相关的，先后顺序是不能人为干预的。  
* 对同一份资源操作时，会存在资源抢夺的问题，需要加入并发控制；  
* 线程会带来额外的开销，如cpu调度时间，并发控制开销；  
* 每个线程在自己的工作内存交互，内存控制不当会造成数据不一致。  
# 二、创建线程
## 2.1 创建的三种方式
* `Thread class`：基础`Thread`类（重点）；  
* `Runnable`接口：实现`Runnable`接口（重点）；
* `Callabel`接口：实现`Callable`接口（了解）。  

## 2.2 线程实现
创建一个新的执行线程有两种方法  
一个是将一个类声明为Thread的子类，这个子类应该重写Thread类的run方法，变形线程执行体，然后可以创建子类的实例，调用start()方法启动线程。  
另一个方法是创建一个线程并声明实现类Runnable接口，并实现run方法，然后分配类的实例，在创建Thread时将实现Runnable接口的实例作为参数传递并启动。  
```java
public class TestThread implements Runnable{
    @Override
    public void run() {
        // run方法线程体
        
    }

    public static void main(String[] args) {        
        // 创建Runnable接口的实现类对象
        TestThread thread1 = new TestThread();
        // 创建线程对象，通过线程对象来开启线程，代理
        Thread thread = new Thread(thread1);
        // 启动线程
        thread.start();       

    }
}
```
### 两种方法的对比 
继承Thread类  
* 子类继承Thread类具备多线程能力；  
* 启动线程方式：子类对象.start();例：  
```java

public class test(){
public static void main(String[] args){
        TestThread station = new ExtendsThread(); 
        station.start();//这是一份资源 
    }

}
 
```  
* 不建议使用：避免OOP单继承局限性。  
  
实现Runnable接口  
* 实现接口Runnable具有多线程能力；  
* 启动线程：传入目标对象 + Thread对象.start();示例：  
```java
// 多个代理
public class test(){
public static void main(String[] args){
  TestThread thread1 = new ExtendsThread();
  new Thread(thread1,"小明").start();
  new Thread(thread1,"小红").start();
  new Thread(thread1,"小芳").start();
}
}

```
* 推荐使用：避免单继承局限性，灵活方便，方便同一对象被多个线程使用  
## 出现的问题
1、多个线程同时操作一个资源时，出现数据紊乱的情况  


## 实现Callable接口  
1、实现Callable接口，需要返回值类型；  
2、重写call方法，需要抛出异常；  
3、创建目标对象；  
4、创建执行服务：ExecutorService ser = Executors.newFixedThreadPool(numsOfThread);  
5、提交执行：Future<Boolean> r1 = ser.submit(threadName);  
6、获取结果：boolean rs1 = r1.get();//call方法返回的结果  
7、关闭服务：ser.shutdownNow();  

# 二、静态代理模式  
代理模式小结：  
1、真实对象和代理对象都要事先同一个接口；  
2、代理对象要代理真实角色，即把真实角色作为参数传入代理对象。  
好处：  
1、代理对象可以做很多真实对象做不了的事情；  
2、真实对象可以专注做自己的事情。  
# 三、Lamda表达式
* 意义：  
避免匿名内部类定义过多；  
让代码更简洁；  
去掉一堆没有意义的代码，只留下核心的逻辑。  
* 函数式接口：  
定义：任何接口，如果只包含唯一一个抽象方法，那么它就是一个函数式接口；  
对于函数式接口，我们可以通过lambda表达式来创建该接口的对象。  
* 小结：  
1、抽象方法没有参数时，小括号不可省；  
2、只有一个参数时，小括号可省；如果有多个参数，就不能省，并且参数类型要么统一都写，要么都不写；
3、只有一条语句时，花括号可省；否则不可省。  
* 演化过程：  
外部类 --> 静态内部类 --> 局部内部类 --> 匿名内部类 --> lambda表达式  
# 四、线程状态
创建状态 --(启动线程)--> 就绪状态 --（获得CPU资源）--> 运行状态 --(线程
自然执行完毕或外部干涉终止线程)--> 死亡状态  
运行状态 --(等待用户输入线程休眠等)--> 阻塞状态 --(阻塞解除)-->就绪状态  
运行状态 --（释放CPU资源）-->就绪状态  
  
新生状态：Thread thread = new Thread()，线程对象一旦创建就进入了新生状态；  
就绪状态：当调用start()方法，线程立即进入就绪状态，但并不意味着立即调度执行；  
运行状态：CPU对就绪状态的线程进行调度，进入运行状态，此时才真正执行线程体的代码块；  
阻塞状态：当调用sleep、wait或同步锁定时，线程进行阻塞状态，就是代码不往下执行，阻塞事件解除后，重新进入就绪状态，等待CPU调度；  
死亡状态：线程中断或者结束，一旦进入死亡状态，就不能再次启动。  
## 4.1 线程停止
stop：
1、建议线程正常停止 --> 利用次数，不建议死循环  
2、建议使用标志位  --> 设置一个标志位  
3、不要使用stop、destroy等过时的或JDK不建议使用的方法  
## 4.2 线程休眠
sleep：
1、sleep（时间）指定当前线程阻塞的毫秒数；  
2、sleep存在异常InterruptedException；  
3、sleep时间达到后线程进行就绪状态；  
4、sleep可以模拟网络延时、倒计时等；  
5、每一个对象都有一个锁，sleep不会释放锁。  
### 应用
* 模拟网络延时：放大问题的发生性！！！  
* 模拟倒计时  
## 4.3 线程礼让
yield：  
1、礼让线程，让当前正在执行的线程暂停，但不阻塞；  
2、将线程从运行状态转为就绪状态；  
3、让CPU重新调度，礼让不一定成功，看CPU调度。  
## 4.4 线程强制执行
join：  
合并线程，待此线程执行完成之后，再执行其他线程，其他线程阻塞，可理解为插队  
## 4.5 线程状态观测
`Thread.State state = thread.getState();`  
注意死亡后线程不能再次启动
## 4.6 线程的优先级
JAVA提供一个线程调度器来监控程序中启动后进入就绪状态的所有线程，线程调度器按照优先级
决定应该调度哪个线程来执行。  
线程的优先级用数字表示，范围从1~10.数字越大优先级越高  
使用以下方法改变或获取优先级：  
    thread1.setPriority(Thread.MIN_PRIORITY);// 设置thread1的优先级  
    Thread.currentThread().getPriority();//获取当前线程的优先级  
注意优先级的设定在start()调度之前。  
## 4.7 守护（daemon）线程
1、线程分为用户线程和守护线程；  
2、虚拟机必须确保用户线程执行完毕；  
3、虚拟机不用等待守护线程执行完毕；  
4、常见的守护线程：后台记录操作日志、监控内存、垃圾回收等。  
5、设置守护线程的方法：threadGod.setDaemon(true);// 将线程threadGod设置为守护线程     

# 五、线程同步  
发生在多个线程操作同一资源。  
## 5.1 并发
并发：同一个对象被多个线程同时操作。
举例：上万人同时抢100张票、两个银行同时取钱、食堂排队        
线程同步：其实就是一种等待机制，多个需要同时访问此对象的线程进入这个对象的等待池形成队列，等待前面
线程使用完毕，下一个线程再使用。形成条件：队列+锁，解决线程同步安全性  
由于同一进程的多个线程共享同一块存储空间，为了保证数据在方法中被访问时的正确性，在访问时加入锁机制
（synchronized），当一个线程获得对象的排它锁，独占资源，其他线程必须等待，使用后释放锁即可。存在以下问题：  
* 1、一个线程持有锁会导致其他所有需要此锁的线程挂起；  
* 2、在多线程竞争下，加锁、释放锁会导致比较多的上下文切换和调度延时，引起性能问题；  
* 3、如果一个优先级高的线程等待一个优先级低的线程释放锁，会导致优先级倒置，引起性能问题。  
## 5.2 Lock  
Lock是显式定义锁，需要手动地开锁和解锁。  
推荐顺序：Lock > synchronized

# 六、线程通信
以生产者消费者模式为例
## 6.1 生产者消费者模式——管程法
双方使用同一个缓冲池，通过缓冲池是否满或是否空来判断双方谁等待谁唤醒。  

## 6.2 生产者消费者模式——信号灯法
双方通过使用同一个信号灯flag，通过信号灯的状态判断双方谁等待谁唤醒。  

## 6.3 生产者消费者模式——线程池法
经常创建和销毁、使用量特别大得资源，比如并发情况下的线程，对性能影响很大。所以提前创建好多个线程，放入线程池中，使用时直接获取，使用完后放回池中，
从而避免频繁创建销毁、实现重复利用。  
好处：  
* 提高响应速度（减少创建新线程的时间）；  
* 降低资源消耗（重复利用线程池中线程，不需要每次都创建）；  
* 便于线程管理。  
  
## 查漏补缺
* 1、每个线程都有自己的工作区域，是从主内存中拷贝的。